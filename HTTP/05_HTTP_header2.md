## HTTP 헤더2

### 캐시와 조건부 요청
- 캐시 미적용
	1. A라는 유저가 실시간 예매사이트에 접속하고, 서버에게 요청하여 예매 목록을 받아옴 (고해상도 이미지와 함께)
	2. A가 새로고침을 할 때마다, 서버에서는 다시 또 이미지를 만들어 유저에게 전달함
- 캐시 적용
	1. A라는 유저가 실시간 예매사이트에 접속하고, 서버에게 요청하여 예매 목록을 받아옴 (고해상도 이미지와 함께). 단, 이때 `cache-contorl: max-age=60`헤더를 같이보냄
	2. A가 새로고침을 할 때마다, `cache-control`을 확인하여 아직 캐시가 만료되지 않으면 이전과 같은 정보를 부라우저내부의 캐시저장소에서 데이터를 가져와 유저에게 전달함
		1. 만약 캐시가 만료된 경우에는 다시 네트워크에서 가져온다. 그리고 캐시를 갱신함
	3. 네트워크를 탈 필요가 없어짐!
- 이점
	- 네트워크 사용안해도됨
	- 네트워크 비용 절감
	- 빠른 사용자 경험

### 검증 헤더와 조건부 요청1
- 만약 캐시가 갱신되었을 떄도 기존과 같은 데이터라면? 로컬의 값과 네트워크의 값이 동일한걸 *검증*할 수 있다면, 굳이 다운받을 필요없음
#### 검증헤더 추가
1. 컨텐츠가 마지막으로 수정된 시각을 헤더에 더해 응답을 보낸다.
	- `Last-Modified: 2020년 11월 10일 10:10:00`
2. 브라우저에서도 마지막으로 수정된 시각을 요청에 보냄
	- `if-modifeid-since: 2020년 11월 10일 10:10:00`
3. 서버가 시각을 비교해 판단함 -> `304 Not Modified` 코드를 내보냄 -> 새로 업데이트할 데이터가 없으니 HTTP Body도 없음!
4. 브라우저는 기존에 저장한 캐시를 다시 가져와서 사용함
-> 어쩔수없이 네트워크를 사용하지만, 데이터 전체를 가져오지 않아서 효율적임
- tip
	- chrome - network 탭에서 캐시로 불러온 자원은 배경이 회색임

### 검증 헤더와 조건부 요청2
- 검증 헤더
	- 캐시데이터와 서버데이터가 같은지 검증하는데 사용
	- Last-Modified
	- Etag
		- 캐시용 데이터에 추가되는 임의의 버전값(해쉬를 데이터의 값으로 만듦 -> 같은 데이터인 경우 같은 해쉬). Etag를 다르면 다시 받는 메커니즘

- 조건부 요청 헤더
	- 조건에 따른 분기
	- if-Modified-Since: Last-Modified 사용
	- if-None-Match: Etag 사용
	- true ? 200 OK : 304 Not Modified

- 캐시는 만료되었지만, 값은 그대로인 이미지 조회 시나리오
	1. 이미지를 다시 조회함
		```text
		cache-control: max-age=60
		if-None-Match: "test" // 이 값은 Etag 이다
		```
	2. 서버에서는 이미지명과 Etag의 값을 비교함
	3. Etag가 같음
	4. 304 Not Modified를 반환함
	5. 브라우저에서는 304에 의해 분기처리되어 캐시된 이미지를 유저에게 보여줌
	> 지금생각해보니, AWS의 cloudfront서비스에서 invalidation하는 기능이 이런 부분을 활용하는것 같다. 연결된 S3의 자원들의 Etag와 비슷한 역할을 하는 헤더값들을 전부 수정해주는 방식이지 않을까?

### 캐시 제어 헤더
- Cache-Control
	- 제어를 위해 사용
	- 옵션 종류
		- max-age=?
			- 초단위로 지정
		- no-cache
			- 캐시는 하되 항성 원서버에서 검증을 거침
		- no-store
			- 민감한 데이터; 저장하지않고 메모리에서 사용후 바로 삭제 (개인정보?)
- Pragma
	- 하위호환
- Expires
	- 유효기간을 날짜로 지정
	- 현재는 Cache-Control: max-age를 추천하며, 같이 사용하면 Expires 옵션은 무시됨

### 프록시 캐시
- 미국에 있는 origin서버 접속시, 반응속도가 느림 -> 프록시 캐시 서버를 한국 어딘가에 둠 -> 한국에 있는 유저는 origin서버에 접근하지 않아도되서 더 빨른 응답을 받는다.
	- ex) 유튜브에서 조회수가 높은 영상은 캐시서버에 저장되서 조회수가 낮은 영상보다 버퍼링이 적다.
- Cache-Control: private
	- 기본값
	- 유저 디바이스의 로컬에 저장되는 캐시
	- 네트워크단에서는 캐시하면 안됨 (로그인 세션)
- Cache-Control: public 캐시
	- 응답이 네트워크상에 캐시되어도 됨

### 캐시 무효화
확실한 캐시 무효화 응답이 필요한 경우
- Cache-Control: no-cache, no-store, must-revalidate
- Pragma: no-cache

#### no-cache vs must-revalidate
- no-cache
	- 프록시캐시서버에서 원서버를 오류로 인해 접근불가능한 경우에도 기존 데이터를 응답함
- must-revalidate
	- 프록시캐시서버에서 원서버를 오류로 인해 접근불가능한 경우, 504오류를 응답함 (ex. 계좌내의 잔액정보)