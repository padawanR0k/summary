<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="./fx.js"></script>
	<title>Document</title>
</head>

<body>
	<script>
		(async () => {
			// 범위값 python 처럼
			// console.log(L.range(10));
			// console.log(...L.range(10));
			// console.log(...L.range(1, 10, 2));
			// console.log(...L.range(0, 10, 2));
			// _.go(
			// 	_.range(10),
			// 	_.each(a => a*2),
			// 	_.each(console.log)
			// )
			// console.log('--');
			// _.go(
			// 	L.range(10),
			// 	L.map(console.log),
			// 	_.takeAll
			// )
			// const join = (sep) => _.reduce((a,b) => `${a}${sep}${b}`)
			// _.go(
			// 	_.range(1, 6),
			// 	_.map(_.range),
			// 	_.map(_.map(a => "*")),
			// 	_.map(join('')),
			// 	join('\n'),
			// 	console.log
			// )
			// *
			// **
			// ***
			// ****
			// *****

			// const join = (sep) => _.reduce((a,b) => `${a}${sep}${b}`)
			// _.go(
			// 	_.range(1, 10, 2),
			// 	_.map(_.range),
			// 	_.map(_.map(a => "*")),
			// 	_.map(join('')),
			// 	_.map((a) => _.go(
			// 		_.range(5-(a.length/2)),
			// 		_.map(_ => ''),
			// 		join(' ')
			// 	) + a),
			// 	join('\n'),
			// 	console.log
			// )
			// 		 *
			//    ***
			//   *****
			//  *******
			// *********
			// const users = [
			// 	{name: 'a', age: 11},
			// 	{name: 'b', age: 21},
			// 	{name: 'c', age: 31},
			// ];
			// const add = (a, b) => a + b;
			// console.log(
			// 	_.reduce(add, L.filter(age => age > 30, L.map(a => a.age, users))),
			// )

			// const obj1 = {
			// 	a: 1,
			// 	b: undefined,
			// 	c: 'CC',
			// 	d: 'DD'
			// }
			// const add = (a, b) => a + b;
			// const qs =
			// 	_.pipe(
			// 		Object.entries,
			// 		_.filter(([,v])=>v),
			// 		_.map(([k,v]) => `${k}=${v}`),
			// 		_.reduce((acc,a) => `${acc}&${a}`)
			// 	)

			// const qs2 = (obj) =>
			// 	_.go(
			// 		obj,
			// 		Object.entries,
			// 		_.filter(([,v])=>v),
			// 		_.map(([k,v]) => `${k}=${v}`),
			// 		_.reduce((acc,a) => `${acc}&${a}`)
			// 	)

			// console.log(qs(obj1)); // a=1&c=CC&d=DD
			// console.log(qs2(obj1)); // a=1&c=CC&d=DD


			// const split = _.curry((sep, str) => str.split(sep));
			// const queryToObject = _.pipe(
			// 	split('&'),
			// 	_.map(split('=')),
			// 	_.map(([k,v])=>({[k]:v})),
			// 	_.reduce(Object.assign)
			// )

			// console.log(queryToObject('a=1&c=CC&d=DD')); /// {a: "1" c: "CC" d: "DD"}


			// const f = x => x + 10;
			// const g = x => x - 5;
			// const fg = x => f(g(x));
			// _.go(
			// 	10,
			// 	fg,
			// 	console.log
			// )

			// _.go(
			// 	[10, null],
			// 	L.map(fg),
			// 	_.each(console.log)
			// )


			// const users = [
			// 	{name: 'a', age: 11},
			// 	{name: 'b', age: 21},
			// 	{name: 'c', age: 31},
			// ];

			// _.find는 못찾으면 undefined리턴

			// const getUser1 = (name) => {
			// 	return _.find(u => u.name === name, users);
			// }

			// const getUser2 = (name) => {
			// 	return _.go(users,
			// 		L.filter(a => a.name === name),
			// 		L.take(1),
			// 		L.map(a => a.age),
			// 		_.each(console.log))
			// }

			// var user = getUser1('z');
			// console.log(user);
			// if (user) {
			// 	console.log(user.age)
			// }

			// 함수형으로 작성된 경우, 진행하려는 행위를 함수합성내부에 넣게된다.
			// 앞서 작성한 부분들에 대해서 만족하지 못해 필터로 값이 걸려진 경우에는 그 뒤에있는 "행위"가 실행되지 않는다.
			// 그러므로 if같은 부분이 추가적으로 필요하지 않게된다.

			// getUser2('z')


			// const obj = {
			// 	a: 1,
			// 	b: 2,
			// 	c: 3,
			// }

			// _.go(
			// 	obj,
			// 	L.entries,
			// 	L.filter(([k,v]) => v%2),
			// 	L.map(([k,v]) => ({[v]: k})),
			// 	_.reduce(Object.assign),
			// 	console.log
			// ) // {1: "a", 3: "c"}


			// const it = (function *() {
			// 	yield 10;
			// 	yield 20;
			// 	yield 30;
			// }())
			// console.log(...it);


			// const object = entries =>
			// 	_.reduce((obj, [k,v]) => (obj[k]=v, obj), {}, entries);
			// console.log(object(L.entries({b:2, c:3})));

			// let m = new Map();
			// m.set('a', 1);
			// m.set('b', 2);
			// m.set('c', 3);
			// console.log(object(m));

			// const object = entries =>
			// _.reduce((obj, [k,v]) => (obj[k]=v, obj), {}, entries);
			// const mapObject = (f, obj) =>
			// 	_.go(
			// 		obj,
			// 		L.entries,
			// 		_.map(([k, v]) => [k, f(v)]),
			// 		object,
			// 	);
			// console.log(mapObject(a => a + 30, {a: 1, b: 2, c: 3}));


			// const obj = {a: 1, b: 2, c: 3};
			// const pick = (keys, obj) => _.go(
			// 	obj,
			// 	_.entries,
			// 	_.filter(([k]) => keys.includes(k)),
			// 	_.object
			// )
			// console.log(pick(['a'], obj));

			// const users = [
			// 	{id: 1, name: 'a', age: 11},
			// 	{id: 2, name: 'b', age: 21},
			// 	{id: 3, name: 'c', age: 31},
			// 	{id: 4, name: 'd', age: 41},
			// ];
			// const indexBy = (f, iter) =>
			// 	_.go(
			// 		_.reduce((obj, a) => (obj[f(a)] = a, obj), {}, iter)
			// 	)

			// console.log(_.indexBy(u => u.id, users))
			// console.log(indexBy(u => u.id, users))



			// const users = [
			// 	{id: 1, name: 'a', age: 11},
			// 	{id: 2, name: 'b', age: 21},
			// 	{id: 3, name: 'c', age: 31},
			// 	{id: 4, name: 'd', age: 41},
			// ];
			// const indexByFilter = (f, iter) =>
			// 	_.go(
			// 		iter,
			// 		L.entries,
			// 		_.filter(([k,v]) => f(v)),
			// 		_.object,
			// 		// console.log
			// 	)
			// const indexed = _.indexBy(u => u.id, users);
			// console.log(indexed);
			// console.log(indexByFilter(a => a.age > 20, indexed))

			// class Model {
			// 	constructor(attrs = {}) {
			// 		this._attrs = attrs;
			// 	}

			// 	get(k) {
			// 		return this._attrs[key];
			// 	}

			// 	set(k, v) {
			// 		this._attrs[k] = v;
			// 		return this;
			// 	}
			// }
			// class Collection {
			// 	constructor(models = []) {
			// 		this._models = models;
			// 	}

			// 	at(idx) {
			// 		return this._models[idx];
			// 	}

			// 	add(model) {
			// 		this._models.push(model);
			// 		return this;
			// 	}

			// 	[Symbol.iterator]() {
			// 		return this._models[Symbol.iterator]()
			// 	}
			// }


			// const coll = new Collection();
			// coll.add(new Model({id: 3, name: 'AA'}))
			// coll.add(new Model({id: 2, name: 'BB'}))

			// 값자체로 순회 불가
			// _.go(
			// 	L.range(2),
			// 	L.map(i => coll.at(i)),
			// 	_.each(console.log)
			// )
			// console.log(...coll);


			// _.go(
			// 	[1,2,3,4,5, 0, 0],
			// 	_.takeWhile(a => a),
			// 	_.each(console.log)
			// )
			// _.go(
			// 	[1,2,3,4,5, 0, 0],
			// 	_.takeUntil(a => a),
			// 	_.each(console.log)
			// )


			const Impt = {
				payments: {
					1: [
						{ imp_id: 11, order_id: 1, amount: 15000},
						{ imp_id: 21, order_id: 2, amount: 25000},
						{ imp_id: 31, order_id: 3, amount: 35000},
					],
					2: [
						{ imp_id: 41, order_id: 1, amount: 150},
						{ imp_id: 51, order_id: 2, amount: 250},
						{ imp_id: 61, order_id: 3, amount: 350},
					],
					3: []
				},
				getPayments: page => {
					console.log('요청중...');
					return _.delay(100, Impt.payments[page])
				}
			}

			const DB = {
				getOrders: ids =>
					_.delay(100, [
						{id: 1},
						{id: 3},
						{id: 7},
					])
			}

			async function job() {
				// 결제된 결제모듈 데이터
				const payments = await _.go(
					L.range(1, 3),
					L.takeUntil(({length}) => length > 0), // 3개이하전까지 진행
					L.map(Impt.getPayments),
					_.flat,
					// L.map(console.log),
					// _.take(3)
				)

				console.log(payments);

				const orderIds = await _.go(
					payments,
					_.map(p => p.order_id),
					DB.getOrders,
					_.map(({id})=> (console.log(id), id)),
					)
				console.log(orderIds)

				// 결제완료 orderIds에 없는 미결제 정보들
				_.go(
					payments,
					_.reject(p => orderIds.includes(p.order_id)),
					console.log
				)
			}
			job();

			// 스케쥴러
			(function recur() {
				Promise.all(
					// job이 4000안에 끝났으면 4000까지 기다리고
					_.delay(4000, undefined),
					// 다음 job을 실행한다.
					job()
				).then(recur)
			}());
		})()
	</script>
</body>

</html>