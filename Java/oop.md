## 클래스와 객체

---

자바는 객체지향언어이다. 현실세계에서의 각의 개체를 객체로 보고 객체를 구현하거나, 특정 개체의 행위를 메소드로 구현하는 것이라고 생각하자.

### 클래스

---

자바에서는 클래스를 다음과 같이 정의한다.

```java
접근제어자 class 클래스명 {
	멤버변수;
	메서드;
}
```

멤버변수는 변수명과 변수의 타입을 가진다.

`int number;`

메서드는 메서드명과 전달받는 파라미터를 가진다. (없을 수 도 있다.)

```java
public void method() {...}
```

***자바에서는 패키지 선언을 맨위에 한다. 클래스명이 같아도 패키지명이 다르면 다른 클래스이다. 유의할점***

### 메소드

---

자바에서는 함수만 따로 작성하는 방법은 없다. 클래스나 인터페이스의 메소드로만 존재한다.

```java
접근제한자 반환값타입 메소드명(파라미터들..) {
	...
}
```

### 클래스와 인스턴스

---

인스턴스는 클래스를 new 예약어를 통해 생성된 데이터를 뜻한다. new 예약어로 생성된 데이터를 특정 변수에 할당하게되면, 해당 변수를 인스턴스 변수라고 한다. 해당 변수는 힙 메모리에 생성된 인스턴스의 주소를 가진채로 스택메모리에 저장된다.

힙 메모리의 주소를 저장하고 있기때문에 인스턴스 변수를  그냥 다른 변수에 대입하게되면  같은 메모리 주소를 참조하고 있게되서, 하나의 변수만 수정해도 다른 변수에서도 수정이 되버리는 원치않은 결과가 나오기때문에 주의해야한다.

### 생성자

---

자바에서는 파이썬과 ts에서와는 다르게 여러 생성자를 가질 수 있다. 인스턴스를 생성할 때 전달된 파라미터에 따라 어떤 생성자를 실행 시킬지 정해진다.

- 생성자 오버로드
    - 생성자가 2개이상 제공된 경우

생성자는 생략도 가능하다. 컴파일러가 자동으로 제공해주기 때문이다.

```java
public class Person{
	String name = "이름없음"
	public Person(){
	}

	public Person(String name) {
		this.name = name;
	}
}

new Person(); // 첫번째 생성자 실행
new Person("홍길동"); // 두번째 생성자 실행
```

### 정보 은닉

---

자바에서는 인스턴스 외부에서 멤버변수에 직접 접근을 방지하기 위해서 여러 접근제어자를 제공한다.

`private` 키워드로 선언한 변수는 외부에서 직접 접근할 수 없기때문에 `getA, setA` 메소드를 선언하여 조회하거나 값을 수정해야한다. (ts에서는 `get set` 예약어를 아예 지원해줘서 더 좋은거같다)

`protcted` 키워드로 선언한 변수는 상속받은 클래스에서만 접근할 수 있다.

## 클래스와 객체 2

---

### this 예약어

---

`this`예약어는 python에서의 `self` , ts에서의 `this` 와 비슷하다. 생성자 함수 실행블록내부에서 인스턴스 자기 자신을 참조 할 때 사용된다.



```java
public class Person{
	String name = ""
	public Person(){
		// 이런식으로 다른 생성자를 호출 할 수도 있다.
		this("이름없음")
	}

	public Person(String name) {
		this.name = name;
	}
}

new Person(); // 첫번째 생성자 실행
```

### static 변수

---

파이썬에서 클래스 변수를 선언했던것과 비슷하다. 클래스의 static변수는 해당 클래스로 생성된 모든 인스턴스가 공유한다.



```java
public class Person {
	public static int population = 0;
	String name = ""
	public Person(){
		// 이런식으로 다른 생성자를 호출 할 수도 있다.
		this("이름없음")
	}

	public Person(String name) {
		this.name = name;
		population = population + 1;
	}
}

new Person(); // population == 1
new Person(); // population == 2
```

### static 메소드

---

static 메소드는 인스턴스를 생성하지 않아도 사용할 수 있는 메소드를 말한다. ts와 동일하게 static 메소드에서는 다른 멤버 변수에 접근할 수 없다. 하지만 static 변수에는 접근가능 하다.

### 변수의 라이프사이클

---

![https://media.vlpt.us/images/uhan2/post/2be38434-4044-4a8a-9449-0df8cdbd38e9/image.png](https://media.vlpt.us/images/uhan2/post/2be38434-4044-4a8a-9449-0df8cdbd38e9/image.png)

### 싱글톤 패턴

---

프로그램에서 하나의 인스턴스만 존재해야할 때, 사용하는 디자인 패턴을 `싱글톤 패턴`이라고 부른다. 자바에서는 static을 응용하여 구현할 수 있다.

```java
public class StaticTest {
	private static StaticTest instance = new StaticTest();
	public static StaticTest getInstance() {
		if (instance == null) {
			intance = new StaticTest();
		}
	}
}
```

## 배열과 ArrayList

---

### 배열선언

---

```java
int []ids = new int[3]; // int 타입데이터가 3개 들어갈 수 있는 배열
int []ids = new int[]{1, 2, 3}; // 이런식으로도 가능
int []ids = {1, 2, 3}; // 이런식으로도 가능

int []ids;
ids = new int[]{1, 2, 3}; // 이런식으로도 가능

// 다차원 배열선언

int[][] arr = {{1,2,3}, {1,2,3}}
```

### ArrayList 클래스

---

실생활의 데이터는 길이가 변하는 일이 잦으며, 데이터 또한 시간이 지남에 따라 달라지기 때문에 길이가 정해져있는 배열은 자주 사용되지 않는다. 이를 보완하기 위해 ArrayList 클래스가 존재한다.

- `ArrayList.get(index)` →E
    - 해당 인덱스에 위치한 값을 반환함
- `ArrayList.remove(index)` → E
    - 해당 인덱스에 위치한 값을 지움
- `ArrayList.add(item)` → boolean
    - 배열에 값을 추가함
- `ArrayList.size()` → int
    - 해당 list의 길이를 반환함
- `ArrayList.isEmpty()` → boolean
    - 해당 list가 비어있는지를 확인함

```java
import java.util.ArrayList;

// 여기서 T는 배열에 들어갈 값들의 타입을 뜻한다.
ArrayList<T> Tlist = new ArrayList<T>();

```

## 상속과 다형성

---

### 상속과 형변환

---

상속 (inheritance)

- 계승
- 상속재산

서비스를 운영하게되면 필수적으로 서비스의 기능이 많아지게된다. 그에 따라 서비스를 코드로 구현한 클래스는 매번 변화하게 된다. 같은 형질을 가진 클래스이지만 다른 부분이 조금씩 존재하여 일부분은 공통적인 기능을 가지고 일부분은 각자 다른기능을 가지게 하기위해 상속 (extends)를 한다고 생각한다.

자바에서는 `extedns` 예약어를 사용하여 클래스를 상속한다.

```java
class Human extends Animal {}
```

`private` 접근제한자로 메소드나 변수를 선언한 경우 상속된 하위 클래스에서만 해당 변수에 접근가능하다!

### 상속에 대한 생성자

---

상속받은 하위 클래스의 인스턴스가 생성될 때, 상위 클래스의 생성자가 먼저 실행된다.

```java

class Human extends Animal {
	public Human() {
		System.out.printIn("2")
	}
}

new Human()
// Animal 클래스의 생성자에 '1'을 출력시키는 코드가 있는 경우
// 1
// 2

```

### `super`

---

하위 클래스에서 상위 클래스에 접근하려면 `super` 예약어를 사용하면 된다.

`super()` → 상위의 `this()`  를 실행한 것과 동일하게 생성자를 실행시킨다.

`super.method()` 이런식으로  상위의 메소드나 변수에도 접근이 가능하다.

### 하위 → 상위클래스 묵시적 형변환

---

하위 클래스의 인스턴스를 할당할 때, 상위클래스로 묵시적 형변환이 가능하다. 반대로는 불가능

```java
Animal man = new Human();
```

### 메서드 오버라이딩

---

하위클래스에서 상위클래스에 이미 존재하는 메서드 명과 같은 메서드를 선언할 때, 메서드를 오버라이딩 했다고 한다. 메서드 바로 위에 `@Override`  라는 어노테이션을 입력하여, 컴파일러에게 오버라이딩된 메서드라는 걸 인식하게 해줘야한다.

메서드 오버라이딩은 기존 메서드와 이름, 받는 파라미터갯수, 타입이 동일해야한다.

메서드 오버리이딩을 하게 되면, 하위클래스에서 상위클래스에 존재하는  메소드명과 동일한 메소드를 실행해도 하위클래스의 메소드를 실행하게 해준다.



### 다형성

---

프로그램 언어의 다형성은 그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들이 다양한 자료형에 속하는 것이 허가되는 성질을 가리킨다. 반댓말은 단형성으로, 프로그램 언어의 각 요소가 한가지 형태만 가지는 성질을 가리킨다.

만약 도형의 너비를 구하는 클래스를 작성한다고 생각해보자.

원, 정사각형, 세모는 도형이라는 범주에 속한다. 하지만 각각 너비를 구하는 방법이 다르다.  이 경우 `getArea`메소드를 가진  `Shape` 라는 클래스를 만들고 `Circle`, `Rectagle`, `Triangle` 클래스가 `Shape`를 확장하여 각각 넓이를 구하는 공식이 다르지만 `getArea`  라는 하나의 메소드를 실행시키게끔하는 것이 다형성이라고 할 수 있겟다.

### 다운 캐스팅과 instanceof

---

특정 이유로 인해  인스턴스를 생성할 때 타입을 상위클래스로 선언한 경우 하위클래스에 존재하는 메소드나 변수에 접근 못할 수 있다. 이때는 클래스 형변환을 사용하여 접근가능하다.

```java
class Animal {
	public void say() {
		System.out.printIn("?")
	}
}

class Human extends Animal {
	public void Hello() {
		System.out.printIn("hi")
	}
}

Animal A = new Human()
A.say();

// js에서도 constructor를 확인할 때 instanceof를 똑같이 사용한다.
if(A instanceof Human) {
	Human man = (Human)A;
	man.hello();
}

```

이는 인스턴스를 생성할 때, `Human`클래스를 사용하였기때문에 가능하다. 만약 `Animal`  을 상속받은 `Dog` 라는 클래스가 있다고하자 이 경우에는 if문을 통과하지 못한다.

## 추상 클래스

---

### 추상 클래스

---

- 추상클래스는 실체코드가 완벽하게 작성되지 않은 클래스이다.  실제 구현하려는 클래스의 뼈대를 잡거나,  여러 클래스가 공통적으로 사용될 구조를 미리 작성하는 클래스이다.
- 추상 클래스 내부에 작성하는 추상 메소드는  실행 코드블럭을 가지지 않는다.  extends한 클래스에서 추상메소드의 구조를 기반으로 코드블럭을 구현하는것이다.
- 추상메서드는 추상클래스 내부에서만 작성가능하다.

### 템플릿 메서드

---

- concrete 메서드를 내부에  abstract 메소드를 실행하고,  `final`  예약어를 사용하여 abstract 메서드를 재정의 불가능하게 만든다. 그러면 해당 메서드를 `final`  예약어때문에 override가 불가능하게된다.  이제 해당 메서드 내부에 존재하는 abstract 메서드는 템플릿 메서드로써 활용된다
- 템플릿 메서드는 특정 행위에 대해 시나리오가 변하지는 않지만 구동하는 방법이 다를 경우, 코드를 각 클래스마다 다르게 구현하기 위해 사용한다.
    - 휘발유 자동차, 전기 자동차가 움직일 수 있는건 같지만, 움직이기 위한 동력을 만드는 방법이 다르듯

### final 예약어

---

`final` 예약어는 뒤에 오는 데이터를 불변하게 만든다.

- `final` 변수
    - 더 이상 변경 할 수 없는 상수가 된다.
    - ex
        - 각 나라의 고유코드
        - 쇼핑몰의 제품 카테고리
- `final` 메서드
    - 하위 클래스에서 재정의가 불가능하다.
    - ex
        - 많은 곳에서 돌려쓰는 메소드이면서 변경되면안되는 중요한 기능일 경우
- `final` 클래스
    - 확장할 수 없는 클래스이다.