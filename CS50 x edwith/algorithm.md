# 알고리즘

알고리즘이란 입력값을 원하는 출력값의 형태로 바꾸기 위해 어떤 **명령들이 수행되어야 하는지에 대한 규칙들의 순서적 나열**이다. 같은 출력값이라도 알고리즘 순서 나열에 따라 출력값에 도달하는 시간은 달라진다.



## 의사코드

의사코드는 컴퓨터가 알아듣게 알고리즘을 작성하기전에 사람이 읽기 편한상태로 알고리즘을 표현 것이다.



## 선형탐색

선형탐색 알고리즘은 정확하지만 아주 비효율적이다. n개의 데이터가 있을 때 n번 만큼 확인해야한다. 선형탐색은 **자료가 정렬이 되어있지않거나 주어진 정보가 없이 탐색해야하는 경우에 유용하다.**



## 버블 정렬

버블 정렬 알고리즘은 두개의 인접한 자료 값을 비교하고 순서에 맞지않으면 두 수의 자리를 교환한다. n개의 원소를 정렬을 한번 수행할 때마다 n번째 원소가 자신의 자리를 찾아가므로 n개의 원소를 정렬하려면 n-1번 수행하여야한다.

버블정렬은 어느정도 정렬이 되어있는 배열이나 데이터의 양이 적은 배열에 효율적이다.

[![img](http://mooc.phinf.nhnnext.org/20170731_193/1501468592248aN1eU_PNG/4.2_-01.png?type=w760)](http://www.edwith.org/cs50/lecture/22857/#)  



## 선택 정렬

선택정렬은 데이터들중에 가장 적은 수 혹은 가장 큰 수를 찾아서 맨 처음이나 맨 끝수와 자리를 교환 해주는 방식의 정렬이다. **교환횟수를 최소화시키지만 자료에 대한 비교횟수는 증가한다.**

정렬하는데 n-1번의 교환이 필요하나, n^2번의 비교가 필요해진다.

[![img](http://mooc.phinf.nhnnext.org/20170731_196/1501469637779l1AIx_PNG/4.3_-01.png?type=w760)](http://www.edwith.org/cs50/lecture/22859/#)  



## 삽입 정렬

삽입 정렬은 자료를 두 부분으로 나눈다. 정렬된 부분과 그렇지 않은 부분, 정렬되지않은 부분의 데이터가 정렬된 부분의 자리로 삽입되는 형태의 정렬방법이다.

삽입 정렬은 **자료의 양이 적을 때** 성능이 우수하며 자료 **대부분이 이미 정렬이 되어있는 경우** 효율적이다.

- 장점: 성능이 좋아서 다른 정렬 알고리즘의 일부로도 쓰인다. 버블 정렬보다 비교횟수가 적다.
- 단점: 데이터 상태, 데이터 한개의 크기에 따라 성능의 편차가 심하다



## 시간 복잡도

알고리즘을 수행할 때 걸리는 시간을 효율적으로 분석하는것을 시간복잡도라고 한다. 시간복잡도가 낮을 수록 연산자의 처리 횟수가 적다는 뜻이다. 고로 시간 복잡도가 낮은 알고리즘은 효율적인 알고리즘이다.



## Big-O 표기법

**Big-O** **표기법**은 컴퓨터 과학에서 “대략”을 나타내는 공식적인 개념으로 최악의 시간복잡도 경우를 나타내는 표현이다.

시간 복잡도를 나타 낼때 가장 지수가 큰 부분만 남긴다.



- 선형탐색
  - 찾는 값이 맨끝에 있다. => O(n)
- 버블 정렬
  - n개의 자료를 찾을 때 n-1쌍을 비교한다. => n^2/ 2 - n / 2 => O(n^2)
- 선택 정렬
  - n개의 자료가 있으면 n-1개의 자료 중 가장 작은 값의 자리와 교환해야한다 => n(n-1)/2 => O(n^2) 버블정렬과 같다.
- 삽입 정렬
  - n개의 자료가 있으면 첫번째 자료는 정렬 되어있다고 생각하고, n-1개의 자료들을 정렬된 자료와 비교한다. => 1 + 2 + … + (n-1)=> O( n^2)

## **Big Ω 표기법** 

Big-O 표기법과 반대로 최선의 경우를 나타낸다.

- 선형탐색
  -  Ω(1)
- 버블 정렬
  - 다 정렬되어있는지 확인이 필요하다. => Ω(n)
- 선택 정렬
  - 최소값을 계속 찾아야한다. => Ω(n^2)
- 삽입 정렬
  - 정렬할 수를 정렬된 부분의 가장 큰 수와 비교해야한다. =>  Ω(n)